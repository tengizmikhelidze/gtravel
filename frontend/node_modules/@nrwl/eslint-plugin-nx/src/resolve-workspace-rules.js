"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.workspaceRules = void 0;
const constants_1 = require("./constants");
/**
 * Optionally, if ts-node and tsconfig-paths are available in the current workspace, apply the require
 * register hooks so that .ts files can be used for writing workspace lint rules.
 *
 * If ts-node and tsconfig-paths are not available, the user can still provide an index.js file in
 * tools/eslint-rules and write their rules in JavaScript and the fundamentals will still work (but
 * workspace path mapping will not, for example).
 */
try {
    require('ts-node').register({
        dir: constants_1.WORKSPACE_PLUGIN_DIR,
    });
    const tsconfigPaths = require('tsconfig-paths');
    // Load the tsconfig from tools/eslint-rules/tsconfig.json
    const tsConfigResult = tsconfigPaths.loadConfig(constants_1.WORKSPACE_PLUGIN_DIR);
    /**
     * Register the custom workspace path mappings with node so that workspace libraries
     * can be imported and used within custom workspace lint rules.
     */
    tsconfigPaths.register({
        baseUrl: tsConfigResult.absoluteBaseUrl,
        paths: tsConfigResult.paths,
    });
}
catch (err) { }
exports.workspaceRules = (() => {
    try {
        /**
         * Currently we only support applying the rules from the user's workspace plugin object
         * (i.e. not other things that plugings can expose like configs, processors etc)
         */
        const { rules } = require(constants_1.WORKSPACE_PLUGIN_DIR);
        const localWorkspaceRules = rules;
        // Apply the namespace to the resolved rules
        const namespacedRules = {};
        for (const [ruleName, ruleConfig] of Object.entries(localWorkspaceRules)) {
            namespacedRules[`${constants_1.WORKSPACE_RULE_NAMESPACE}/${ruleName}`] = ruleConfig;
        }
        return namespacedRules;
    }
    catch (err) {
        return {};
    }
})();
//# sourceMappingURL=resolve-workspace-rules.js.map